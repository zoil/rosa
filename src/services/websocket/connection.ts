import { Service, Container } from "typedi";
import * as SockJS from "sockjs";
import * as Promise from "bluebird";
import * as ejson from "ejson";
import * as Async from "async";
import chalk from "chalk";

// Types
import {
  ProtocolType,
  ProtocolConnectionInterface
} from "../../types/websocket";
import { QueryId, SessionId, ConnectionState, Protocols } from "rosa-shared";
import { Message } from "../../types/websocket";

// Services
import { SessionDataFactory, SessionData } from "../session/data";
import SessionMeta from "../session/meta";

// Other
import ProtocolHandshake from "../../protocols/handshake";
import ProtocolV1 from "../../protocols/v1";

/**
 * Factory Service for creating wrappers of SockJS Connections.
 * It has a Protocol attached to it, which defines the Client facing
 * Websocket interface.
 */
@Service()
export default class WebsocketConnectionFactory {
  create(conn: SockJS.Connection) {
    return new WebsocketConnection(conn);
  }
}

/**
 * Wrapper class to deal with all things regarding a single Websocket client
 * connection.
 */
export class WebsocketConnection {
  /**
   * This is the actual SockJS connection instance
   */
  private conn: SockJS.Connection;

  /**
   * The Protocol Strategy for dealing with receiving and sending
   * Client communication.
   */
  private protocol!: ProtocolType;

  /**
   * Unprocessed outgoing Messages.
   */
  private outgoingMessagesQueue: Async.AsyncQueue<Message>;

  /**
   * Unprocessed incoming Messages.
   */
  private incomingMessagesQueue: Async.AsyncQueue<Message>;

  /**
   * The Session Id generated by Rosa (this is not the SockJS Id)
   */
  sessionId!: SessionId;

  /**
   * External session variables accessor object.
   */
  session: SessionData | null = null;

  /**
   * Tells us what state `this` is in.
   */
  state: ConnectionState = ConnectionState.Disconnected;

  /**
   * Wrapper for `onStateChangeCallback()`.
   */
  private onStateChange(): Promise<void> {
    return Promise.try(() => this.onStateChangeCallback(this));
  }

  /**
   * Callback to notify the subscriber when this.state changes.
   */
  private onStateChangeCallback!: (conn: WebsocketConnection) => void;

  /**
   * Callback to notify the subscriber when the connection closes.
   */
  private onDisconnectCallback!: (conn: WebsocketConnection) => void;

  /**
   * Wrapper for `onDisconnectCallback()`.
   */
  private onDisconnect(): Promise<void> {
    return Promise.try(() => this.onDisconnectCallback(this));
  }

  /**
   * Async queue worker for incoming messages.
   */
  private processIncomingMessage(
    message: Message,
    callback: (err?: Error, msg?: string) => void
  ) {
    if (!this.protocol) {
      throw new Error("no protocol");
    }

    // Try and process `message`.
    console.log(chalk.yellow("<-"), this.protocol.getVersion(), message.type);
    Promise.try(() => this.protocol.onData(message))
      // Was there an uncaught error?
      .catch(err => {
        // Log it and tell the Client.
        console.log(err);
        this.protocol.sendError(message, 0);
      })
      // Finally get to the next item in the queue
      .finally(callback);
  }

  /**
   * Async queue worker for outgoing messages.
   */
  private processOutgoingMessage(
    message: Message,
    callback: (err?: Error, msg?: string) => void
  ) {
    try {
      console.log(chalk.blue("->"), this.protocol.getVersion(), message.type);
      const payload = [
        message.requestId ? message.requestId : 0,
        message.type,
        message.payload
      ];
      const stringPayload = ejson.stringify(payload);
      this.emit(stringPayload);
    } catch (err) {
      console.log("Error sending message");
    } finally {
      callback();
    }
  }

  private getSessionId(): SessionId {
    return this.sessionId;
  }

  private getSession(): SessionData | null {
    return this.session;
  }

  /**
   * Set the Protocol for `this`.
   */
  private setProtocol(protocol: ProtocolType) {
    console.log("** Protocol switched", protocol.getVersion());
    this.protocol = protocol;
    protocol.init(this.getProtocolConnectionInterface());
  }

  /**
   * Return the interface the Protocols will talk to.
   */
  private getProtocolConnectionInterface(): ProtocolConnectionInterface {
    return {
      disconnect: this.disconnect.bind(this),
      sendMessage: this.sendMessage.bind(this),
      queueIncomingMessage: this.queueIncomingMessage.bind(this),
      setProtocolForVersion: this.setProtocolByVersion.bind(this),
      createNewSession: this.createNewSession.bind(this),
      reuseSession: this.reuseSession.bind(this),
      ensureSessionIsSet: this.ensureSessionIsSet.bind(this),
      getSessionId: this.getSessionId.bind(this),
      getSession: this.getSession.bind(this)
    };
  }

  /**
   * Wire up `this` for `conn`.
   */
  constructor(conn: SockJS.Connection) {
    console.log("** Connect");
    this.conn = conn;

    // wire up SockJS
    this.conn.on("data", this.onData.bind(this));
    this.conn.on("close", this.onDisconnect.bind(this));

    // set up incoming & outgoing tubes
    this.incomingMessagesQueue = Async.queue(
      this.processIncomingMessage.bind(this),
      1
    );
    this.outgoingMessagesQueue = Async.queue(
      this.processOutgoingMessage.bind(this),
      1
    );

    this.setProtocolByVersion(Protocols.Handshake.ID);
  }

  /**
   * Ensure that the Session is available on `this`.
   * In the lack of it, throw an Error.
   */
  ensureSessionIsSet() {
    if (this.state !== ConnectionState.Ready || !this.sessionId) {
      throw new Error("Unauthorized");
    }
  }

  /**
   * Method for other modules to subscribe certain events of `this`.
   */
  on(
    event: "stateChange" | "disconnect",
    callback: (conn: WebsocketConnection) => {}
  ): WebsocketConnection {
    switch (event) {
      case "stateChange":
        this.onStateChangeCallback = callback;
        break;
      case "disconnect":
        this.onDisconnectCallback = callback;
        break;
    }
    return this;
  }

  /**
   * This is called when a Websocket Client sends something to the server.
   */
  onData(payloadString: string) {
    const message: Message = Object.create(null);
    try {
      // try and parse `payloadString` into `message`.
      const payload = ejson.parse(payloadString);
      const [requestId, messageType, messagePayload] = payload;
      message.type = messageType;
      message.payload = messagePayload;
      message.requestId = requestId;
    } catch (err) {
      // Invalid request.
      // there was an error parsing `payloadString`, let's build up an
    }

    // Queue `message` to be processed.
    this.queueIncomingMessage(message);
  }

  /**
   * Set the State of `this`.
   */
  setState(newState: ConnectionState): Promise<void> {
    this.state = newState;
    return this.onStateChange();
  }

  /**
   * Define the SessionId on `this` and do related followup tasks.
   */
  setSessionId(sessionId: SessionId): Promise<void> {
    this.sessionId = sessionId;
    const sessionDataFactory = Container.get(SessionDataFactory);
    this.session = sessionDataFactory.create(this.sessionId);
    const sessionMetaService = Container.get(SessionMeta);
    sessionMetaService.resetExpiry(sessionId, true);
    return this.setState(ConnectionState.Ready);
  }

  /**
   * Create a new Session for this.conn.
   * This will be called by new Clients.
   */
  createNewSession() {
    return Promise.try(() => {
      // do we have a session set up already?
      if (this.state === ConnectionState.Ready) {
        throw new Error("Session was already set.");
      }
      // No session yet, let's create one!
      const sessionMetaService = Container.get(SessionMeta);
      return sessionMetaService.createNewSession();
    }).then((session: { id: SessionId; secret: string }) => {
      const { id, secret } = session;
      this.setSessionId(id);
      return {
        id,
        secret
      };
    });
  }

  /**
   * Try reusing an existing Session for returning Clients.
   */
  reuseSession(
    sessionId: SessionId,
    signature: string,
    timestamp: number
  ): Promise<any> {
    return Promise.try(() => {
      if (
        // do we have a session set up already?
        this.state === ConnectionState.Ready ||
        !!this.sessionId
      ) {
        // this request is invalid.
        throw new Error("Session was already set.");
      }

      // all ok
      const sessionMetaService = Container.get(SessionMeta);
      return sessionMetaService.authenticate(sessionId, signature, timestamp);
    }).then(sessionId => this.setSessionId(sessionId).then(() => sessionId));
  }

  /**
   * Send `message` to the Client.
   */
  sendMessage(message: Message) {
    this.outgoingMessagesQueue.push(message);
  }

  /**
   * Emit `payload` in the SockJS connection of `this`.
   */
  emit(payload: string): boolean {
    if (this.conn.readyState === 1 && this.conn.writable) {
      return this.conn.write(payload);
    }
    return false;
  }

  /**
   * Disconnect the Websocket Client.
   */
  disconnect() {
    console.log("** Disconnect");
    this.incomingMessagesQueue.pause();
    this.incomingMessagesQueue.drain();
    this.outgoingMessagesQueue.pause();
    this.outgoingMessagesQueue.drain();
    const sessionMetaService = Container.get(SessionMeta);
    this.setState(ConnectionState.Disconnected)
      .then(this.onDisconnect.bind(this))
      .then(() => sessionMetaService.resetExpiry(this.sessionId, false))
      .finally(() => {
        delete this.protocol;
        delete this.sessionId;
        delete this.session;
        delete this.conn;
      });
  }

  /**
   * Event receiver for full data reloads of Queries.
   */
  onSubscriptionData(queryId: QueryId, payload: any) {
    return this.protocol.onSubscriptionData(queryId, payload);
  }

  /**
   * Event receiver for full data reloads of Queries.
   */
  onSubscriptionChanges(queryId: QueryId, changeSet: any) {
    return this.protocol.onSubscriptionChanges(queryId, changeSet);
  }

  /**
   * Queue `message` for processing.
   */
  queueIncomingMessage(message: Message) {
    this.incomingMessagesQueue.push(message);
  }

  /**
   * Return ProtocolType for `version` or `false` if `version` is not supported.
   */
  setProtocolByVersion(version: string): boolean {
    let protocol: ProtocolType | false = false;
    switch (version) {
      case Protocols.V1.ID:
        protocol = new ProtocolV1();
        break;
      case Protocols.Handshake.ID:
      default:
        protocol = new ProtocolHandshake();
    }
    if (!protocol) {
      return false;
    }

    const payload: Protocols.Handshake.Server.SwitchProtocolPayload = {
      version: protocol.getVersion()
    };
    const response = Protocols.Handshake.Server.messageFactory(
      Protocols.Handshake.Server.Tokens.SwitchProtocol,
      payload
    );
    this.sendMessage(response);

    // Use the chosen protocol.
    this.setProtocol(protocol);

    return true;
  }
}
